// Code generated by mockery v1.0.0. DO NOT EDIT.

package db

import (
	context "context"

	mock "github.com/stretchr/testify/mock"
)

// MockOperation is an autogenerated mock type for the Operation type
type MockOperation struct {
	mock.Mock
}

type OperationDownloadArgs struct {
	Ctx         context.Context
	CtxAnything bool
	Dst         string
	DstAnything bool
}

type OperationDownloadReturns struct {
	Err error
}

type OperationDownloadExpectation struct {
	Args    OperationDownloadArgs
	Returns OperationDownloadReturns
}

func (_m *MockOperation) ApplyDownloadExpectation(e OperationDownloadExpectation) {
	var args []interface{}
	if e.Args.CtxAnything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args.Ctx)
	}
	if e.Args.DstAnything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args.Dst)
	}
	_m.On("Download", args...).Return(e.Returns.Err)
}

func (_m *MockOperation) ApplyDownloadExpectations(expectations []OperationDownloadExpectation) {
	for _, e := range expectations {
		_m.ApplyDownloadExpectation(e)
	}
}

// Download provides a mock function with given fields: ctx, dst
func (_m *MockOperation) Download(ctx context.Context, dst string) error {
	ret := _m.Called(ctx, dst)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, dst)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

type OperationNeedsUpdateArgs struct {
	CliVersion         string
	CliVersionAnything bool
	Skip               bool
	SkipAnything       bool
}

type OperationNeedsUpdateReturns struct {
	Need bool
	Err  error
}

type OperationNeedsUpdateExpectation struct {
	Args    OperationNeedsUpdateArgs
	Returns OperationNeedsUpdateReturns
}

func (_m *MockOperation) ApplyNeedsUpdateExpectation(e OperationNeedsUpdateExpectation) {
	var args []interface{}
	if e.Args.CliVersionAnything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args.CliVersion)
	}
	if e.Args.SkipAnything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args.Skip)
	}
	_m.On("NeedsUpdate", args...).Return(e.Returns.Need, e.Returns.Err)
}

func (_m *MockOperation) ApplyNeedsUpdateExpectations(expectations []OperationNeedsUpdateExpectation) {
	for _, e := range expectations {
		_m.ApplyNeedsUpdateExpectation(e)
	}
}

// NeedsUpdate provides a mock function with given fields: cliVersion, skip
func (_m *MockOperation) NeedsUpdate(cliVersion string, skip bool) (bool, error) {
	ret := _m.Called(cliVersion, skip)

	var r0 bool
	if rf, ok := ret.Get(0).(func(string, bool) bool); ok {
		r0 = rf(cliVersion, skip)
	} else {
		r0 = ret.Get(0).(bool)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, bool) error); ok {
		r1 = rf(cliVersion, skip)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}
